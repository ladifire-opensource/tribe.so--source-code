function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useClickable } from "@chakra-ui/clickable";
import { useDescendant, useDescendants } from "@chakra-ui/descendant";
import { useControllableState, useDisclosure, useFocusOnHide, useId, useIds, useOutsideClick, useShortcut, useUpdateEffect } from "@chakra-ui/hooks";
import { usePopper } from "@chakra-ui/popper";
import { addItem, callAllHandlers, dataAttr, focus, getNextIndex, getNextItemFromSearch, getPrevIndex, isArray, isString, removeItem } from "@chakra-ui/utils";
import { mergeRefs, createContext, normalizeEventKey, getValidChildren } from "@chakra-ui/react-utils";
import * as React from "react";
var [MenuProvider, useMenuContext] = createContext({
  strict: false,
  name: "MenuContext"
});
export { MenuProvider, useMenuContext };

/**
 * React Hook to manage a menu
 *
 * It provides the logic and will be used with react context
 * to propagate its return value to all children
 */
export function useMenu(props) {
  var {
    id,
    closeOnSelect = true,
    closeOnBlur = true,
    autoSelect = true,
    isLazy,
    placement = "bottom-start"
  } = props;
  var {
    isOpen,
    onOpen,
    onClose,
    onToggle
  } = useDisclosure(props);
  /**
   * Prepare the reference to the menu and disclosure
   */

  var menuRef = React.useRef(null);
  var buttonRef = React.useRef(null);
  useOutsideClick({
    ref: menuRef,
    handler: event => {
      var _buttonRef$current;

      if (isOpen && closeOnBlur && !((_buttonRef$current = buttonRef.current) != null && _buttonRef$current.contains(event.target))) {
        onClose();
      }
    }
  });
  /**
   * Add some popper.js for dynamic positioning
   */

  var popper = usePopper(_extends({
    placement
  }, props));
  var [focusedIndex, setFocusedIndex] = React.useState(-1);
  /**
   * Context to register all menu item nodes
   */

  var domContext = useDescendants();
  /**
   * Focus the button when we close the menu
   */

  useUpdateEffect(() => {
    if (!isOpen) {
      setFocusedIndex(-1);
    }
  }, [isOpen]);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  /**
   * Generate unique ids for menu's list and button
   */

  var [buttonId, menuId] = useIds(id, "menu-button", "menu-list");
  var openAndFocusMenu = React.useCallback(() => {
    onOpen();
    focus(menuRef.current, {
      nextTick: true
    });
  }, [onOpen, menuRef]);
  var openAndFocusFirstItem = React.useCallback(() => {
    onOpen();
    setFocusedIndex(0);
  }, [onOpen, setFocusedIndex]);
  var openAndFocusLastItem = React.useCallback(() => {
    onOpen();
    setFocusedIndex(domContext.descendants.length - 1);
  }, [onOpen, setFocusedIndex, domContext.descendants]);
  var refocus = React.useCallback(() => {
    var _menuRef$current, _domContext$descendan;

    var hasFocusWithin = (_menuRef$current = menuRef.current) == null ? void 0 : _menuRef$current.contains(document.activeElement);
    var shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus) return;
    var el = (_domContext$descendan = domContext.descendants[focusedIndex]) == null ? void 0 : _domContext$descendan.element;
    el == null ? void 0 : el.focus({
      preventScroll: true
    });
  }, [isOpen, focusedIndex, domContext.descendants]);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    domContext,
    popper,
    buttonId,
    menuId,
    forceUpdate: popper.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy
  };
}
export function useMenuButton(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var menu = useMenuContext();
  var {
    isOpen,
    onClose,
    autoSelect,
    popper,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    openAndFocusMenu
  } = menu;
  var onClick = React.useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      var action = autoSelect ? openAndFocusFirstItem : openAndFocusMenu;
      action();
    }
  }, [autoSelect, isOpen, onClose, openAndFocusFirstItem, openAndFocusMenu]);
  var onKeyDown = React.useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Enter: openAndFocusFirstItem,
      ArrowDown: openAndFocusFirstItem,
      ArrowUp: openAndFocusLastItem
    };
    var action = keyMap[eventKey];

    if (action) {
      event.preventDefault();
      event.stopPropagation();
      action(event);
    }
  }, [openAndFocusFirstItem, openAndFocusLastItem]);

  var buttonProps = _extends({}, props, {
    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers(props.onClick, onClick),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });

  return buttonProps;
}
/**
 * React Hook to manage a menu list.
 *
 * The assumption here is that the `useMenu` hook is used
 * in a component higher up the tree, and its return value
 * is passed as `context` to this hook.
 */

export function useMenuList(props, ref) {
  if (ref === void 0) {
    ref = null;
  }

  var menu = useMenuContext();

  if (!menu) {
    throw new Error("useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>");
  }

  var {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    domContext: {
      descendants
    },
    isLazy
  } = menu;
  /**
   * Hook that creates a keydown event handler that listens
   * to printable keyboard character press
   */

  var onCharacterPress = useShortcut({
    preventDefault: event => event.key !== " "
  });
  var onKeyDown = React.useCallback(event => {
    var eventKey = normalizeEventKey(event);
    var keyMap = {
      Tab: event => {
        event.preventDefault();
      },
      Escape: onClose,
      ArrowDown: () => {
        var nextIndex = getNextIndex(focusedIndex, descendants.length);
        setFocusedIndex(nextIndex);
      },
      ArrowUp: () => {
        var prevIndex = getPrevIndex(focusedIndex, descendants.length);
        setFocusedIndex(prevIndex);
      }
    };
    var fn = keyMap[eventKey];

    if (fn) {
      event.preventDefault();
      fn(event);
      return;
    }

    var characterHandler = onCharacterPress(character => {
      /**
       * Typeahead: Based on current character pressed,
       * find the next item to be selected
       */
      var nextItem = getNextItemFromSearch(descendants, character, node => {
        var _node$element;

        return ((_node$element = node.element) == null ? void 0 : _node$element.textContent) || "";
      }, descendants[focusedIndex]);

      if (nextItem) {
        var index = descendants.indexOf(nextItem);
        setFocusedIndex(index);
      }
    });
    characterHandler(event);
  }, [descendants, focusedIndex, onCharacterPress, onClose, setFocusedIndex]);
  return _extends({}, props, {
    ref: mergeRefs(menuRef, ref),
    children: !isLazy || isOpen ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: _extends({}, props.style, {
      transformOrigin: "var(--popper-transform-origin)"
    }),
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  });
}
export function useMenuPositioner(props) {
  if (props === void 0) {
    props = {};
  }

  var {
    popper,
    isOpen
  } = useMenuContext();
  return _extends({}, props, {
    ref: popper.popperRef,
    style: {
      visibility: isOpen ? "visible" : "hidden"
    }
  });
}
export function useMenuItem(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    isDisabled,
    isFocusable
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["onMouseEnter", "onMouseMove", "onMouseLeave", "onClick", "isDisabled", "isFocusable"]);

  var menu = useMenuContext();
  var {
    domContext,
    setFocusedIndex,
    focusedIndex,
    closeOnSelect,
    onClose,
    menuRef,
    isOpen
  } = menu;
  var ref = React.useRef(null);
  var id = "menuitem-" + useId();
  /**
   * Register the menuitem's node into the domContext
   */

  var index = useDescendant({
    element: ref.current,
    context: domContext,
    disabled: isDisabled,
    focusable: isFocusable
  });
  var onMouseEnter = React.useCallback(event => {
    onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
    if (isDisabled) return;
    setFocusedIndex(index);
  }, [setFocusedIndex, index, isDisabled, onMouseEnterProp]);
  var onMouseMove = React.useCallback(event => {
    onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);

    if (document.activeElement !== ref.current) {
      onMouseEnter(event);
    }
  }, [onMouseEnter, onMouseMoveProp]);
  var onMouseLeave = React.useCallback(event => {
    onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
    if (isDisabled) return;
    setFocusedIndex(-1);
  }, [setFocusedIndex, isDisabled, onMouseLeaveProp]);
  var onClick = React.useCallback(event => {
    onClickProp == null ? void 0 : onClickProp(event);
    /**
     * Close menu and parent menu's if `closeOnSelect` is set to `true`
     */

    if (closeOnSelect) {
      onClose();
    }
  }, [onClose, onClickProp, closeOnSelect]);
  var isFocused = index === focusedIndex;
  var trulyDisabled = isDisabled && !isFocusable;
  useUpdateEffect(() => {
    if (!isOpen) return;

    if (isFocused && !trulyDisabled && ref.current) {
      focus(ref.current, {
        nextTick: true
      });
    } else if (document.activeElement !== menuRef.current) {
      var _menuRef$current2;

      (_menuRef$current2 = menuRef.current) == null ? void 0 : _menuRef$current2.focus();
    }
  }, [isFocused, trulyDisabled, menuRef, isOpen]);
  var tabbable = useClickable({
    onClick,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(ref, externalRef),
    isDisabled,
    isFocusable
  });
  return _extends({}, htmlProps, tabbable, {
    id,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  });
}
export function useMenuOption(props, externalRef) {
  if (externalRef === void 0) {
    externalRef = null;
  }

  var {
    onClick,
    isDisabled,
    isFocusable,
    type = "radio",
    isChecked
  } = props,
      rest = _objectWithoutPropertiesLoose(props, ["onClick", "isDisabled", "isFocusable", "type", "isChecked"]);

  var hookProps = {
    isDisabled,
    isFocusable,
    onClick
  };
  var optionsProps = useMenuItem(hookProps, externalRef);
  return _extends({}, rest, optionsProps, {
    role: "menuitem" + type,
    "aria-checked": isChecked
  });
}
export function useMenuOptionGroup(props) {
  var {
    children,
    type = "radio",
    value: valueProp,
    defaultValue,
    onChange: onChangeProp
  } = props,
      htmlProps = _objectWithoutPropertiesLoose(props, ["children", "type", "value", "defaultValue", "onChange"]);

  var isRadio = type === "radio";
  var fallback = isRadio ? "" : [];
  var [value, setValue] = useControllableState({
    defaultValue: defaultValue != null ? defaultValue : fallback,
    value: valueProp,
    onChange: onChangeProp
  });
  var onChange = React.useCallback(selectedValue => {
    if (type === "radio" && isString(value)) {
      setValue(selectedValue);
    }

    if (type === "checkbox" && isArray(value)) {
      var nextValue = value.includes(selectedValue) ? removeItem(value, selectedValue) : addItem(value, selectedValue);
      setValue(nextValue);
    }
  }, [value, setValue, type]);
  var validChildren = getValidChildren(children);
  var clones = validChildren.map(child => {
    /**
     * We've added an internal `id` to each `MenuItemOption`,
     * let's use that for type-checking.
     *
     * We can't rely on displayName or the element's type since
     * they can be changed by the user.
     */
    if (child.type.id !== "MenuItemOption") return child;

    var onClick = event => {
      onChange(child.props.value);
      child.props.onClick == null ? void 0 : child.props.onClick(event);
    };

    var isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
    return /*#__PURE__*/React.cloneElement(child, {
      type,
      onClick,
      isChecked
    });
  });
  return _extends({}, htmlProps, {
    children: clones
  });
}
export function useMenuState() {
  var {
    isOpen,
    onClose
  } = useMenuContext();
  return {
    isOpen,
    onClose
  };
}
//# sourceMappingURL=use-menu.js.map