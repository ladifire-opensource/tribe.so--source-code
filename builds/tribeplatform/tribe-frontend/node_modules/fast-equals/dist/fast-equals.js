(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global['fast-equals'] = {}));
}(this, function (exports) { 'use strict';

  var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';
  var keys = Object.keys;
  /**
   * @function addToCache
   *
   * add object to cache if an object
   *
   * @param value the value to potentially add to cache
   * @param cache the cache to add to
   */
  function addToCache(value, cache) {
      if (value && typeof value === 'object') {
          cache.add(value);
      }
  }
  /**
   * @function hasPair
   *
   * @description
   * does the `pairToMatch` exist in the list of `pairs` provided based on the
   * `isEqual` check
   *
   * @param pairs the pairs to compare against
   * @param pairToMatch the pair to match
   * @param isEqual the equality comparator used
   * @param meta the meta provided
   * @returns does the pair exist in the pairs provided
   */
  function hasPair(pairs, pairToMatch, isEqual, meta) {
      var length = pairs.length;
      var pair;
      for (var index = 0; index < length; index++) {
          pair = pairs[index];
          if (isEqual(pair[0], pairToMatch[0], meta) &&
              isEqual(pair[1], pairToMatch[1], meta)) {
              return true;
          }
      }
      return false;
  }
  /**
   * @function hasValue
   *
   * @description
   * does the `valueToMatch` exist in the list of `values` provided based on the
   * `isEqual` check
   *
   * @param values the values to compare against
   * @param valueToMatch the value to match
   * @param isEqual the equality comparator used
   * @param meta the meta provided
   * @returns does the value exist in the values provided
   */
  function hasValue(values, valueToMatch, isEqual, meta) {
      var length = values.length;
      for (var index = 0; index < length; index++) {
          if (isEqual(values[index], valueToMatch, meta)) {
              return true;
          }
      }
      return false;
  }
  /**
   * @function sameValueZeroEqual
   *
   * @description
   * are the values passed strictly equal or both NaN
   *
   * @param a the value to compare against
   * @param b the value to test
   * @returns are the values equal by the SameValueZero principle
   */
  function sameValueZeroEqual(a, b) {
      return a === b || (a !== a && b !== b);
  }
  /**
   * @function isPlainObject
   *
   * @description
   * is the value a plain object
   *
   * @param value the value to test
   * @returns is the value a plain object
   */
  function isPlainObject(value) {
      return value.constructor === Object || value.constructor == null;
  }
  /**
   * @function isPromiseLike
   *
   * @description
   * is the value promise-like (meaning it is thenable)
   *
   * @param value the value to test
   * @returns is the value promise-like
   */
  function isPromiseLike(value) {
      return !!value && typeof value.then === 'function';
  }
  /**
   * @function isReactElement
   *
   * @description
   * is the value passed a react element
   *
   * @param value the value to test
   * @returns is the value a react element
   */
  function isReactElement(value) {
      return !!(value && value.$$typeof);
  }
  /**
   * @function getNewCacheFallback
   *
   * @description
   * in cases where WeakSet is not supported, creates a new custom
   * object that mimics the necessary API aspects for cache purposes
   *
   * @returns the new cache object
   */
  function getNewCacheFallback() {
      return Object.create({
          _values: [],
          add: function (value) {
              this._values.push(value);
          },
          has: function (value) {
              return this._values.indexOf(value) !== -1;
          },
      });
  }
  /**
   * @function getNewCache
   *
   * @description
   * get a new cache object to prevent circular references
   *
   * @returns the new cache object
   */
  var getNewCache = (function (canUseWeakMap) {
      if (canUseWeakMap) {
          return function _getNewCache() {
              return new WeakSet();
          };
      }
      return getNewCacheFallback;
  })(HAS_WEAKSET_SUPPORT);
  /**
   * @function createCircularEqualCreator
   *
   * @description
   * create a custom isEqual handler specific to circular objects
   *
   * @param [isEqual] the isEqual comparator to use instead of isDeepEqual
   * @returns the method to create the `isEqual` function
   */
  function createCircularEqualCreator(isEqual) {
      return function createCircularEqual(comparator) {
          var _comparator = isEqual || comparator;
          return function circularEqual(a, b, cache) {
              if (cache === void 0) { cache = getNewCache(); }
              var hasA = cache.has(a);
              var hasB = cache.has(b);
              if (hasA || hasB) {
                  return hasA && hasB;
              }
              addToCache(a, cache);
              addToCache(b, cache);
              return _comparator(a, b, cache);
          };
      };
  }
  /**
   * @function toPairs
   *
   * @description
   * convert the map passed into pairs (meaning an array of [key, value] tuples)
   *
   * @param map the map to convert to [key, value] pairs (entries)
   * @returns the [key, value] pairs
   */
  function toPairs(map) {
      var pairs = new Array(map.size);
      var index = 0;
      map.forEach(function (value, key) {
          pairs[index++] = [key, value];
      });
      return pairs;
  }
  /**
   * @function toValues
   *
   * @description
   * convert the set passed into values
   *
   * @param set the set to convert to values
   * @returns the values
   */
  function toValues(set) {
      var values = new Array(set.size);
      var index = 0;
      set.forEach(function (value) {
          values[index++] = value;
      });
      return values;
  }
  /**
   * @function areArraysEqual
   *
   * @description
   * are the arrays equal in value
   *
   * @param a the array to test
   * @param b the array to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta object to pass through
   * @returns are the arrays equal
   */
  function areArraysEqual(a, b, isEqual, meta) {
      var length = a.length;
      if (b.length !== length) {
          return false;
      }
      for (var index = 0; index < length; index++) {
          if (!isEqual(a[index], b[index], meta)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @function areMapsEqual
   *
   * @description
   * are the maps equal in value
   *
   * @param a the map to test
   * @param b the map to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta map to pass through
   * @returns are the maps equal
   */
  function areMapsEqual(a, b, isEqual, meta) {
      if (a.size !== b.size) {
          return false;
      }
      var pairsA = toPairs(a);
      var pairsB = toPairs(b);
      var length = pairsA.length;
      for (var index = 0; index < length; index++) {
          if (!hasPair(pairsB, pairsA[index], isEqual, meta) ||
              !hasPair(pairsA, pairsB[index], isEqual, meta)) {
              return false;
          }
      }
      return true;
  }
  var OWNER = '_owner';
  var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
  /**
   * @function areObjectsEqual
   *
   * @description
   * are the objects equal in value
   *
   * @param a the object to test
   * @param b the object to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta object to pass through
   * @returns are the objects equal
   */
  function areObjectsEqual(a, b, isEqual, meta) {
      var keysA = keys(a);
      var length = keysA.length;
      if (keys(b).length !== length) {
          return false;
      }
      var key;
      for (var index = 0; index < length; index++) {
          key = keysA[index];
          if (!hasOwnProperty(b, key)) {
              return false;
          }
          if (key === OWNER && isReactElement(a)) {
              if (!isReactElement(b)) {
                  return false;
              }
          }
          else if (!isEqual(a[key], b[key], meta)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @function areRegExpsEqual
   *
   * @description
   * are the regExps equal in value
   *
   * @param a the regExp to test
   * @param b the regExp to test agains
   * @returns are the regExps equal
   */
  function areRegExpsEqual(a, b) {
      return (a.source === b.source &&
          a.global === b.global &&
          a.ignoreCase === b.ignoreCase &&
          a.multiline === b.multiline &&
          a.unicode === b.unicode &&
          a.sticky === b.sticky &&
          a.lastIndex === b.lastIndex);
  }
  /**
   * @function areSetsEqual
   *
   * @description
   * are the sets equal in value
   *
   * @param a the set to test
   * @param b the set to test against
   * @param isEqual the comparator to determine equality
   * @param meta the meta set to pass through
   * @returns are the sets equal
   */
  function areSetsEqual(a, b, isEqual, meta) {
      if (a.size !== b.size) {
          return false;
      }
      var valuesA = toValues(a);
      var valuesB = toValues(b);
      var length = valuesA.length;
      for (var index = 0; index < length; index++) {
          if (!hasValue(valuesB, valuesA[index], isEqual, meta) ||
              !hasValue(valuesA, valuesB[index], isEqual, meta)) {
              return false;
          }
      }
      return true;
  }

  var isArray = Array.isArray;
  var HAS_MAP_SUPPORT = typeof Map === 'function';
  var HAS_SET_SUPPORT = typeof Set === 'function';
  var OBJECT_TYPEOF = 'object';
  function createComparator(createIsEqual) {
      var isEqual = 
      /* eslint-disable no-use-before-define */
      typeof createIsEqual === 'function'
          ? createIsEqual(comparator)
          : comparator;
      /* eslint-enable */
      /**
       * @function comparator
       *
       * @description
       * compare the value of the two objects and return true if they are equivalent in values
       *
       * @param a the value to test against
       * @param b the value to test
       * @param [meta] an optional meta object that is passed through to all equality test calls
       * @returns are a and b equivalent in value
       */
      function comparator(a, b, meta) {
          if (sameValueZeroEqual(a, b)) {
              return true;
          }
          if (a && b && typeof a === OBJECT_TYPEOF && typeof b === OBJECT_TYPEOF) {
              if (isPlainObject(a) && isPlainObject(b)) {
                  return areObjectsEqual(a, b, isEqual, meta);
              }
              var arrayA = isArray(a);
              var arrayB = isArray(b);
              if (arrayA || arrayB) {
                  return arrayA === arrayB && areArraysEqual(a, b, isEqual, meta);
              }
              var aDate = a instanceof Date;
              var bDate = b instanceof Date;
              if (aDate || bDate) {
                  return aDate === bDate && sameValueZeroEqual(a.getTime(), b.getTime());
              }
              var aRegExp = a instanceof RegExp;
              var bRegExp = b instanceof RegExp;
              if (aRegExp || bRegExp) {
                  return aRegExp === bRegExp && areRegExpsEqual(a, b);
              }
              if (isPromiseLike(a) || isPromiseLike(b)) {
                  return a === b;
              }
              if (HAS_MAP_SUPPORT) {
                  var aMap = a instanceof Map;
                  var bMap = b instanceof Map;
                  if (aMap || bMap) {
                      return aMap === bMap && areMapsEqual(a, b, isEqual, meta);
                  }
              }
              if (HAS_SET_SUPPORT) {
                  var aSet = a instanceof Set;
                  var bSet = b instanceof Set;
                  if (aSet || bSet) {
                      return aSet === bSet && areSetsEqual(a, b, isEqual, meta);
                  }
              }
              return areObjectsEqual(a, b, isEqual, meta);
          }
          return false;
      }
      return comparator;
  }

  // comparator
  var deepEqual = createComparator();
  var shallowEqual = createComparator(function () { return sameValueZeroEqual; });
  var circularDeepEqual = createComparator(createCircularEqualCreator());
  var circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));

  exports.circularDeepEqual = circularDeepEqual;
  exports.circularShallowEqual = circularShallowEqual;
  exports.createCustomEqual = createComparator;
  exports.deepEqual = deepEqual;
  exports.sameValueZeroEqual = sameValueZeroEqual;
  exports.shallowEqual = shallowEqual;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=fast-equals.js.map
